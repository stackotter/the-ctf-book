By looking at the source code (in `challenge.c`), we can see that we have another buffer overflow.
This time, we can't just simply overwrite the return address of `main`, because `win` checks to make
sure that `is_awesome` is true, but it is false by default. To make `is_awesome` true, we have to
call `toggle_is_awesome` before calling `win`.

To call one function after another with a buffer overflow we can simply write a second return
address after the first return address in most cases.

See `exploit.py` for a full working exploit.
