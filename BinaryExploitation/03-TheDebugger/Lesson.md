# The debugger | Binary exploitation part 3

The debugger is an essential tool in the binary exploitation toolkit, especially when you don't have
any source code for the target program. Debuggers allow you to watch a program's execution
step-by-step, view the causes of crashes, inspect a program's state at certain points during its
execution, and more. In this course we will use `gdb` (the other major debugger is `lldb`). Lets
take a look around.

## Running a program

As we explore the debugger we will be debugging the challenge binary from the `debug_me` challenge.
`gdb` outputs a lot of unnecessary output sometimes, so I will be omitting that for brevity. Running
a program in `gdb` is relatively simple, just run `gdb` on the program and then use the `run`
command (Figure 3.1).

```console
$ gdb ./debug_me
gdb) run
Starting program: ./debug_me
There's no way you can win
Terrible try
[Inferior 1 (process 169) exited normally]
```
Figure 3.1: *running the program in gdb*

Wow, that's not a very gracious program, I bet it's wrong though, we can definitely win.

## Disassembling functions

Sometimes we need to view the the assembly code of a function in a program (when we don't have
source code available). Getting the assembly code of a function from an executable file is called
disassembling the function. Lets see what the disassembly of the `main` function looks like (Figure
3.2).

```console
gdb) disas main
Dump of assembler code for function main:
   0x0000000000401132 <+0>:	push   rbp
   0x0000000000401133 <+1>:	mov    rbp,rsp
   0x0000000000401136 <+4>:	sub    rsp,0x10
   0x000000000040113a <+8>:	mov    DWORD PTR [rbp-0x4],0x0
   0x0000000000401141 <+15>:	lea    rdi,[rip+0xebc]        # 0x402004
   0x0000000000401148 <+22>:	call   0x401030 <puts@plt>
   0x000000000040114d <+27>:	cmp    DWORD PTR [rbp-0x4],0x0
   0x0000000000401151 <+31>:	je     0x401161 <main+47>
   0x0000000000401153 <+33>:	lea    rdi,[rip+0xec5]        # 0x40201f
   0x000000000040115a <+40>:	call   0x401040 <system@plt>
   0x000000000040115f <+45>:	jmp    0x40116d <main+59>
   0x0000000000401161 <+47>:	lea    rdi,[rip+0xec9]        # 0x402031
   0x0000000000401168 <+54>:	call   0x401030 <puts@plt>
   0x000000000040116d <+59>:	mov    eax,0x0
   0x0000000000401172 <+64>:	leave
   0x0000000000401173 <+65>:	ret
End of assembler dump.
```
Figure 3.2: *disassembly of the main function*

That's quite a lot to take in at once, lets break it down (refer to Figure 3.3 for annotations). You
don't need to understand the assembly at this point, but you may find it useful to understand at
least the general gist of what the assembly code is doing.

1. The `lea` instruction is short for `load effective address`, and evaluates the result of a
   pointer expression. In this case it adds `0xebc` to the `rip` pointer (which points to the next
   instruction) and then stores the result in the `rdi` register. In this case the value of
   `rip+0xebc` at that instruction will always be `0x402004` (as gdb helpfully points out), but the
   program was compiled like this so that it doesn't matter where in memory the code is located, it
   can always find the data because the data will always be offset from the code by the same amount.
   This is a concept called position independent code which we will learn more about later.

   To find out the value located at `0x402004` you can run `p (char *)0x402004` (assuming that the
   value is a string).
2. `DWORD PTR [rbp-0x4]` gets the value of the `DWORD` located at the pointer (ptr) `rbp - 4`. A
   `DWORD` is a double word, which is just a fancy way of saying 4 bytes. All this does is gets the
   value of the 32-bit integer located 4 bytes before the address contained in `rbp`.

```asm
<+0>:  push   rbp
<+1>:  mov    rbp,rsp
<+4>:  sub    rsp,0x10
<+8>:  mov    DWORD PTR [rbp-0x4],0x0 #    set value at `rbp - 0x4` to 0
<+15>: lea    rdi,[rip+0xebc]         # 1. 0x402004, the address of "There's no way you can win" in memory
<+22>: call   0x401030 <puts@plt>     #    call `puts(rdi)`
<+27>: cmp    DWORD PTR [rbp-0x4],0x0 # 2. compare value at `rbp - 0x4` to 0
<+31>: je     0x401161 <main+47>      #    if value at `rbp - 0x4` is `0`, skip to <+47> (else branch, this is an if-else block)

<+33>: lea    rdi,[rip+0xec5]         #    0x40201f, the address of "/bin/cat flag.txt" in memory
<+40>: call   0x401040 <system@plt>   #    call `system(rdi)`
<+45>: jmp    0x40116d <main+59>      #    jump to the line after the else branch (finish the if branch)

<+47>: lea    rdi,[rip+0xec9]         #    0x402031, the address of "Terrible try" in memory
<+54>: call   0x401030 <puts@plt>     #    call `puts(rdi)`

<+59>: mov    eax,0x0                 #    eax stores the return value, equivalent to `return 0;`
<+64>: leave
<+65>: ret
```
Figure 3.3: *annotated disassembled main function*

## Setting breakpoints

Sometimes, we want to stop the execution of a program when a certain instruction is reached. This is
what breakpoints are for. Lets set a breakpoint at `main+15` and run the program again (Figure 3.4).

```console
gdb) b *main+15
Breakpoint 1 at 0x401141
gdb) run
Starting program: ./debug_me
Breakpoint 1, 0x0000000000401141 in main ()
gdb) disas main
Dump of assembler code for function main:
   0x0000000000401132 <+0>:	push   rbp
   0x0000000000401133 <+1>:	mov    rbp,rsp
   0x0000000000401136 <+4>:	sub    rsp,0x10
   0x000000000040113a <+8>:	mov    DWORD PTR [rbp-0x4],0x0
=> 0x0000000000401141 <+15>:	lea    rdi,[rip+0xebc]        # 0x402004
   0x0000000000401148 <+22>:	call   0x401030 <puts@plt>
   0x000000000040114d <+27>:	cmp    DWORD PTR [rbp-0x4],0x0
   0x0000000000401151 <+31>:	je     0x401161 <main+47>
   0x0000000000401153 <+33>:	lea    rdi,[rip+0xec5]        # 0x40201f
   0x000000000040115a <+40>:	call   0x401040 <system@plt>
   0x000000000040115f <+45>:	jmp    0x40116d <main+59>
   0x0000000000401161 <+47>:	lea    rdi,[rip+0xec9]        # 0x402031
   0x0000000000401168 <+54>:	call   0x401030 <puts@plt>
   0x000000000040116d <+59>:	mov    eax,0x0
   0x0000000000401172 <+64>:	leave
   0x0000000000401173 <+65>:	ret
End of assembler dump.
```
Figure 3.4: *setting a breakpoint and running the program*

As you can see, we have stopped just before executing the instruction at `main+15` (denoted by gdb with
a `=>` in Figure 3.4). To step to the next instruction we can run `si` (Figure 3.5). `si` is short
for step instruction, which means gdb will allow the program to run one instruction and then it'll
pause execution again.

```console
gdb) si
0x0000000000401148 in main ()
```
Figure 3.5: *stepping to the next instruction*

Neat, we've now stopped at 0x401148 which is the address of the instruction after `main+15`.

## Solving the challenge

Before reading on, try and figure out what condition/s need to be met for the flag to be printed out
by the program. My annotations in Figure 3.3 might help you decipher the assembly code.

For the flag to be printed out, we need to change the value stored at `rbp - 4` to anything other
than `0`. This isn't too difficult with `gdb`. We can use `set` to set the value to `1` and the `c`
to continue execution of the program until it either reaches another breakpoint or finishes
executing (Figure 3.6).

```console
gdb) set {int}($rbp-4) = 1
gdb) c
Continuing.
There's no way you can win
[Detaching after vfork from child process 218]
flag{d3bugg3r5_ar3_t00_p0w3rfu1_i_w15h_i_kn3w_h0w_t0_u53_1}
[Inferior 1 (process 215) exited normally]
```
Figure 3.6: *exploit the program by editing the variable during execution*

Awesome, it worked!

## That was cool and all, but...

As powerful as the debugger seems for solving challenges, you have to keep in mind that you can't
use a debugger as part of your final exploit. This is because operating system developers already
thought of this and made sure that you have to already be an administrator to use a debugger on
anything 'important' (look up suid binaries). But don't worry, you can still use a debugger to poke
around and figure out how the program works to aid you in creating your final working exploit. It's
also a great tool for figuring out why an exploit isn't working.

## Cheatsheet

Whenever you see `expr`, that means that any expression as excepted for that argument. Some examples
of expressions: `$rbp` gets the value of `$rbp`, `(char)0x41` is the number `0x41` as a character
(`A`), `$rbp+$rdi*4` does some arithmetic on the values of `rbp` and `rdi`, `main` is the address of
the `main` function, etc.

| Command              | What it does                         |
| -------------------- | ------------------------------------ |
| `p expr`             | Prints the value of an expression    |
| `si`                 | Executes one instruction             |
| `b expr`             | Sets a breakpoint                    |
| `c`                  | Continues execution                  |
| `finish`             | Finish execution of current function |
| `info frame`         | Get info about current stack frame   |
| `info proc mappings` | List memory regions                  |

Figure 3.7: *gdb command cheatsheet*
