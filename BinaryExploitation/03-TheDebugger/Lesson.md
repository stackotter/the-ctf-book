# The debugger | Binary exploitation part 3

The debugger is an essential tool in the binary exploitation toolkit, especially when you don't have
any source code for the target program. Debuggers allow you to watch a program's execution
step-by-step, view the causes of crashes, inspect a program's state at certain points during its
execution, and more. In this course we will use `gdb` (the other major debugger is `lldb`). Lets
take a look around.

## Running a program

As we explore the debugger we will be debugging the challenge binary from the `debug_me` challenge.
`gdb` outputs a lot of unnecessary output sometimes, so I will be omitting that for brevity. Running
a program in `gdb` is relatively simple, just run `gdb` on the program and then use the `run`
command (Figure 3.1).

```console
$ gdb ./debug_me
gdb) run
Starting program: ./debug_me
There's no way you can win
Terrible try
[Inferior 1 (process 169) exited normally]
```
Figure 3.1: *running the program in gdb*

Wow, that's not a very gracious program, I bet it's wrong though, we can definitely win.

## Disassembling functions

Sometimes we need to view the the assembly code of a function in a program (when we don't have
source code available). Getting the assembly code of a function from an executable file is called
disassembling the function. Lets see what the disassembly of the `main` function looks like (Figure
3.2).

```console
gdb) disas main
Dump of assembler code for function main:
   0x0000000000401132 <+0>:	push   rbp
   0x0000000000401133 <+1>:	mov    rbp,rsp
   0x0000000000401136 <+4>:	sub    rsp,0x10
   0x000000000040113a <+8>:	mov    DWORD PTR [rbp-0x4],0x0
   0x0000000000401141 <+15>:	mov    edi,0x402004
   0x0000000000401146 <+20>:	call   0x401030 <puts@plt>
   0x000000000040114b <+25>:	cmp    DWORD PTR [rbp-0x4],0x0
   0x000000000040114f <+29>:	je     0x40115d <main+43>
   0x0000000000401151 <+31>:	mov    edi,0x40201f
   0x0000000000401156 <+36>:	call   0x401040 <system@plt>
   0x000000000040115b <+41>:	jmp    0x401167 <main+53>
   0x000000000040115d <+43>:	mov    edi,0x402031
   0x0000000000401162 <+48>:	call   0x401030 <puts@plt>
   0x0000000000401167 <+53>:	mov    eax,0x0
   0x000000000040116c <+58>:	leave
   0x000000000040116d <+59>:	ret
End of assembler dump.Arglist at 0x7fffffffead0, args:
 Locals at 0x7fffffffead0, Previous frame's sp is 0x7fffffffeae0
 Saved registers:
  rbp at 0x7fffffffead0, rip at 0x7fffffffead8
```
Figure 3.2: *disassembly of the main function*

That's quite a lot to take in at once, lets break it down (refer to Figure 3.3 for annotations). You
don't need to understand the assembly at this point, but you may find it useful to understand at
least the general gist of what the assembly code is doing.

1. To find out the value located at `0x402004` you can run `p (char *)0x402004` (assuming that the
   value is a string).

   You may be wondering why the instruction is setting `edi` while my annotation says it's setting
   `rdi`. This is because `edi` is just the lower 4 bytes of `rdi`, and 0x402004 is only 3 bytes, so
   setting `edi` is equivalent to setting `rdi` in this case. The compiler does this because the
   instruction `mov edi,0x00402004` takes up 5 less machine code bytes than `mov
   rdi,0x0000000000402004`.
2. `DWORD PTR [rbp-0x4]` gets the value of the `DWORD` located at the pointer (ptr) `rbp - 4`. A
   `DWORD` is a double word, which is just a fancy way of saying 4 bytes. All this does is gets the
   value of the 32-bit integer located 4 bytes before the address contained in `rbp`.

```asm
<+0>:	push   rbp
<+1>:	mov    rbp,rsp
<+4>:	sub    rsp,0x10
<+8>:	mov    DWORD PTR [rbp-0x4],0x0 #    set value at `rbp - 0x4` to 0
<+15>:	mov    edi,0x402004            # 1. set rdi to the address of "There's no way you can win" in memory
<+20>:	call   0x401030 <puts@plt>     #    call `puts(rdi)`
<+25>:	cmp    DWORD PTR [rbp-0x4],0x0 # 2. compare value at `rbp - 0x4` to 0
<+29>:	je     0x40115d <main+43>      #    if value at `rbp - 0x4` is `0`, skip to <+47> (else branch, this is an if-else block)

<+31>:	mov    edi,0x40201f            #    set rdi to the address of "/bin/cat flag.txt" in memory
<+36>:	call   0x401040 <system@plt>   #    call `system(rdi)`
<+41>:	jmp    0x401167 <main+53>      #    jump to the line after the else branch (finish the if branch)

<+43>:	mov    edi,0x402031            #    set rdi to the address of "Terrible try" in memory
<+48>:	call   0x401030 <puts@plt>     #    call `puts(rdi)`

<+53>:	mov    eax,0x0                 #    eax stores the return value, equivalent to `return 0;`
<+58>:	leave
<+59>:	ret
```
Figure 3.3: *annotated disassembled main function*

## Setting breakpoints

Sometimes, we want to stop the execution of a program when a certain instruction is reached. This is
what breakpoints are for. Lets set a breakpoint at `main+15` and run the program again (Figure 3.4).

```console
gdb) b *main+15
Breakpoint 1 at 0x401141

gdb) run
Starting program: ./debug_me
Breakpoint 1, 0x0000000000401141 in main ()

gdb) disas main
Dump of assembler code for function main:
   0x0000000000401132 <+0>:	push   rbp
   0x0000000000401133 <+1>:	mov    rbp,rsp
   0x0000000000401136 <+4>:	sub    rsp,0x10
   0x000000000040113a <+8>:	mov    DWORD PTR [rbp-0x4],0x0
=> 0x0000000000401141 <+15>:	mov    edi,0x402004
   0x0000000000401146 <+20>:	call   0x401030 <puts@plt>
   0x000000000040114b <+25>:	cmp    DWORD PTR [rbp-0x4],0x0
   0x000000000040114f <+29>:	je     0x40115d <main+43>
   0x0000000000401151 <+31>:	mov    edi,0x40201f
   0x0000000000401156 <+36>:	call   0x401040 <system@plt>
   0x000000000040115b <+41>:	jmp    0x401167 <main+53>
   0x000000000040115d <+43>:	mov    edi,0x402031
   0x0000000000401162 <+48>:	call   0x401030 <puts@plt>
   0x0000000000401167 <+53>:	mov    eax,0x0
   0x000000000040116c <+58>:	leave
   0x000000000040116d <+59>:	ret
End of assembler dump.
```
Figure 3.4: *setting a breakpoint and running the program*

As you can see, we have stopped just before executing the instruction at `main+15` (denoted by gdb with
a `=>` in Figure 3.4). To step to the next instruction we can run `si` (Figure 3.5). `si` is short
for step instruction, which means gdb will allow the program to run one instruction and then it'll
pause execution again.

```console
gdb) si
0x0000000000401148 in main ()
```
Figure 3.5: *stepping to the next instruction*

Neat, we've now stopped at 0x401148 which is the address of the instruction after `main+15`.

## Solving the challenge

Before reading on, try and figure out what condition/s need to be met for the flag to be printed out
by the program. My annotations in Figure 3.3 might help you decipher the assembly code.

For the flag to be printed out, we need to change the value stored at `rbp - 4` to anything other
than `0`. This isn't too difficult with `gdb`. We can use `set` to set the value to `1` and the `c`
to continue execution of the program until it either reaches another breakpoint or finishes
executing (Figure 3.6).

```console
gdb) set {int}($rbp-4) = 1

gdb) c
Continuing.
There's no way you can win
[Detaching after vfork from child process 218]
flag{d3bugg3r5_ar3_s0_p0w3rfu1_i_w15h_i_kn3w_h0w_t0_u53_1}
[Inferior 1 (process 215) exited normally]
```
Figure 3.6: *exploit the program by editing the variable during execution*

Awesome, it worked!

## That was cool and all, but...

As powerful as the debugger seems for solving challenges, you have to keep in mind that you can't
use a debugger as part of your final exploit. This is because operating system developers already
thought of this and made sure that you have to already be an administrator to use a debugger on
anything 'important' (look up suid binaries). But don't worry, you can still use a debugger to poke
around and figure out how the program works to aid you in creating your final working exploit. It's
also a great tool for figuring out why an exploit isn't working.

## Cheatsheet

Whenever you see `expr`, that means that any expression as excepted for that argument. Some examples
of expressions: `$rbp` gets the value of `$rbp`, `(char)0x41` is the number `0x41` as a character
(`A`), `$rbp+$rdi*4` does some arithmetic on the values of `rbp` and `rdi`, `main` is the address of
the `main` function, etc.

| Command              | What it does                                          |
| -------------------- | ----------------------------------------------------- |
| `p expr`             | Prints the value of an expression                     |
| `si`                 | Executes one instruction                              |
| `b expr`             | Sets a breakpoint                                     |
| `c`                  | Continues execution                                   |
| `finish`             | Finishes execution of current function                |
| `info frame`         | Gets info about current stack frame                   |
| `info proc mappings` | Lists memory regions                                  |
| `x/20gx expr`        | Prints 20 8 byte values starting from the addr `expr` |

Figure 3.7: *gdb command cheatsheet*

If you need to do something that's not in the cheatsheet, Google is your best friend as always.

## Exploiting buffer overflows without source code

Now that you've got the basics of using `gdb`, you should give the `out_of_bbq` challenge a go. The
vulnerability is similar to the one in `gets_me_every_time`, the main difference being a lack of
source code this time.

### Solution

There are two main ways to find out the size of the input buffer: bruteforce (like the exploit
script at `02-out_of_bbq/Solution/exploit.py` does) and reading the disassembly.

Lets try the second method to test our gdb skills.

First, we'll run the program in gdb and type is a large amount of `a`s to see if we can cause a
crash (Figure 3.8). As you can see, the program did crash, and inspecting the stack frame shows us
that the return address is now `0x6161616161616161` (hexadecimal for `aaaaaaaa`), exactly what we
would expect.

```console
$ gdb ./challenge
gdb) run
Starting program: ./challenge
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
Program received signal SIGSEGV, Segmentation fault.
0x000000000040117e in main ()

gdb) info frame
Stack level 0, frame at 0x7fffffffead8:
 rip = 0x40117e in main; saved rip = 0x6161616161616161
 Arglist at 0x6161616161616161, args:
 Locals at 0x6161616161616161, Previous frame's sp is 0x7fffffffeae0
 Saved registers:
  rip at 0x7fffffffead8
```
Figure 3.8: *checking that the program has a buffer overflow*

Now we must figure out how many bytes we need to overwrite. Lets enter a small input and see how
many more bytes we need to write to overwrite the return address (Figure 3.9). We'll set a
breakpoint just after the call to `gets` in main so that we can inspect the stack frame right after
our input has been stored.

```console
gdb) disas main
Dump of assembler code for function main:
   ...
   0x0000000000401167 <+20>:	call   0x401050 <gets@plt>
   0x000000000040116c <+25>:	lea    rax,[rbp-0x30]
   ...
End of assembler dump.

gdb) b *main+25
Breakpoint 1 at 0x40116c

gdb) run
Starting program: /root/shared/CyberSecurityClub/BinaryExploitation/03-TheDebugger/02-out_of_bbq/challenge
abcd

Breakpoint 1, 0x000000000040116c in main ()
gdb) p (char *)$rax
$1 = 0x7fffffffeaa0 "abcd"
```
Figure 3.9: *setting a breakpoint after `gets` and entering a small input*

As you can see the breakpoint worked, and we are now at the instruction right after the call to
`gets`. From reading the `man` page for `gets` (with `man gets`), I know that the `gets` function
returns the address of the string that it was passed. As well as this, we know that the `rax`
register often stores the return value of a function (Figure 2.1). I ran `p (char *)$rax` to test
this assumption, and sure enough, that's the string we typed in.

To figure out how many bytes to write, lets have a bit more of a poke around (Figure 3.10). First
I'll use `x/20gx $rax` to view 160 bytes of the string pointed to by `rax` (which will most likely
include more than just the string, hopefully we'll be able to see the return address). To figure out
where the return address is located, I'll use `p $rbp+8` because we know that the return address is
8 bytes past `rbp` (Figure 2.3). I'll also run the `info frame` command to find the value of the
return address so that we can verify that we're looking in the right spot.

```console
gdb) x/20gx $rax
0x7fffffffeaa0:	0x0000000064636261	0x0000000000000000
0x7fffffffeab0:	0x0000000000401180	0x0000000000401060
0x7fffffffeac0:	0x00007fffffffebc0	0x0000000000000000
0x7fffffffead0:	0x0000000000401180	0x00007ffff7e26d0a  <- the return address we want to overwrite
0x7fffffffeae0:	0x00007fffffffebc8	0x0000000100000000
0x7fffffffeaf0:	0x0000000000401153	0x00007ffff7e267cf
0x7fffffffeb00:	0x0000000000000000	0x4d22e8f1355fbb77
0x7fffffffeb10:	0x0000000000401060	0x0000000000000000
0x7fffffffeb20:	0x0000000000000000	0x0000000000000000
0x7fffffffeb30:	0xb2dd178ec39fbb77	0xb2dd07b5cfd9bb77

gdb) p $rbp+8
$6 = (void *) 0x7fffffffead8

gdb) info frame
Stack level 0, frame at 0x7fffffffeae0:
 rip = 0x40116c in main; saved rip = 0x7ffff7e26d0a
  ...
```
Figure 3.10: *inspecting the stack after entering a small input*

I have annotated the location of the return address to make it easier to identify. As you can see,
it is located at `rbp+8` and has the value that `info frame` told us it should. Now we can just
count how many bytes are between the start of the string and the return address. In this case it
happens to be `7*8` which is 56 bytes. If we wanted the length of the input buffer we could just
subtract 8 from this (to exclude the saved rbp).

The rest of the exploit is the same as `gets_me_every_time`. You can either adapt your solution for
that challenge or test your knowledge by attempting to make a new exploit from scratch.
