# Ghidra | Binary exploitation part 4

Once programs get a bit more complex, figuring out how they work can become too difficult to do with
just a debugger. This is where decompilers such as Ghidra come in handy.

## What is a decompiler?

A decompiler is a program that attempts to reverse the process of compiling a program. It takes in
an executable file and produces the C code for each function. Usually this produced C code won't
look exactly like the original C code because local variable names are lost (or all variables if the
executable has been stripped). The aim of a decompiler is not to produce C code that can be
recompiled, it is to create C code that expresses the logic of the program as closely as possible.

## What is Ghidra?

Ghidra is a decompiler developed by the NSA, who released it to the public in 2019 for free. It
isn't perfect, but it is by far the best free decompiler, and can even compete with most payed
decompilers.

## Installing Ghidra

Ghidra is written in Java, and requires an installation of JDK 17. Ghidra is a GUI application, so
if you are using a headless (GUI-less) Linux instance such as a docker container or Windows
Subsystem for Linux, you will need to install Ghidra on your computer's main operating system
instead of your virtual OS.

Installation instructions can be found in [Ghidra's GitHub repository](https://github.com/NationalSecurityAgency/ghidra#install).

## Basic Ghidra usage

If you're using macOS or Linux, open `ghidraRun`. If you're using Windows, open `ghidraRun.bat`.

The first thing you'll want to do is create a new project. To do so, select the `File > New Project` menu
item, click `Next`, give the project a name, and click `Finish`.

In this lesson we will be analyzing the binary from the challenge `volatile_passcode`. To import the
executable, select the `File > Import File` menu item, select the challenge executable, click
`Select File To Import`, click `OK`, and click `OK` once more.

To open the executable in the decompiler, double click the executable in the project's tree view.
Ghidra will ask you whether you want to analyse the binary. Click `Yes` and then click `Analyze`.
Analysis shouldn't take long at all because the binary is so small.

## A quick tour

The `Symbol Tree` pane is a good place to start. It contains all of the program symbols (functions,
global variables, labels, etc.). Expanding the `Functions` category reveals all of the program's
functions. In the case of `volatile_passcode`, only three of these functions (`main`, `sighandler`
and `generate_passcode`) are interesting to us at the moment. The rest of the functions are
automatically generated by the C compiler for a variety of purposes.

Let's double click on the `main` function to open its decompilation. The `Decompile` pane contains
the decompiled function, and the `Listing` pane contains the disassembled function, similar to what
`disas main` would give you in gdb.

In lesson 1, you learnt about the `strings` tool. Ghidra has a more reliable version of this tool
which you can reach by selecting the `Window > Defined Strings` menu item.

## Why not use gdb?

To understand why Ghidra is useful for this challenge, let's quickly open up `volatile_passcode` in
gdb and poke around (Figure 4.1). The disassembly of `main` seems pretty similar to what we've seen
previously, but it calls a function called `generate_passcode`. The disassembly of
`generate_passcode` looks much less manageable, and as a beginner assembly reader, it's going to be
a bit too much to take in.

```console
gdb) disas main
Dump of assembler code for function main:
   0x0000000000001293 <+0>:	push   rbp
   0x0000000000001294 <+1>:	mov    rbp,rsp
   0x0000000000001297 <+4>:	sub    rsp,0x10
   0x000000000000129b <+8>:	lea    rsi,[rip+0xffffffffffffffd0]        # 0x1272 <sighandler>
   0x00000000000012a2 <+15>:	mov    edi,0xe
   0x00000000000012a7 <+20>:	call   0x1070 <signal@plt>
   0x00000000000012ac <+25>:	mov    edi,0x1
   0x00000000000012b1 <+30>:	call   0x1060 <alarm@plt>
   0x00000000000012b6 <+35>:	mov    eax,0x0
   0x00000000000012bb <+40>:	call   0x11a5 <generate_passcode>
   0x00000000000012c0 <+45>:	mov    DWORD PTR [rbp-0x4],eax
   0x00000000000012c3 <+48>:	lea    rdi,[rip+0xd6a]        # 0x2034
   0x00000000000012ca <+55>:	mov    eax,0x0
   0x00000000000012cf <+60>:	call   0x1050 <printf@plt>
   0x00000000000012d4 <+65>:	lea    rax,[rbp-0x8]
   0x00000000000012d8 <+69>:	mov    rsi,rax
   0x00000000000012db <+72>:	lea    rdi,[rip+0xd67]        # 0x2049
   0x00000000000012e2 <+79>:	mov    eax,0x0
   0x00000000000012e7 <+84>:	call   0x1090 <__isoc99_scanf@plt>
   0x00000000000012ec <+89>:	mov    eax,DWORD PTR [rbp-0x8]
   0x00000000000012ef <+92>:	cmp    DWORD PTR [rbp-0x4],eax
   0x00000000000012f2 <+95>:	jne    0x1302 <main+111>
   0x00000000000012f4 <+97>:	lea    rdi,[rip+0xd51]        # 0x204c
   0x00000000000012fb <+104>:	call   0x1040 <system@plt>
   0x0000000000001300 <+109>:	jmp    0x130e <main+123>
   0x0000000000001302 <+111>:	lea    rdi,[rip+0xd55]        # 0x205e
   0x0000000000001309 <+118>:	call   0x1030 <puts@plt>
   0x000000000000130e <+123>:	mov    eax,0x0
   0x0000000000001313 <+128>:	leave
   0x0000000000001314 <+129>:	ret
End of assembler dump.

gdb) disas generate_passcode
Dump of assembler code for function generate_passcode:
   0x0000000000401162 <+0>:	push   rbp
   0x0000000000401163 <+1>:	mov    rbp,rsp
   0x0000000000401166 <+4>:	sub    rsp,0x10
   0x000000000040116a <+8>:	lea    rax,[rbp-0x10]
   0x000000000040116e <+12>:	mov    rdi,rax
   0x0000000000401171 <+15>:	call   0x401060 <time@plt>
   0x0000000000401176 <+20>:	mov    DWORD PTR [rbp-0x4],0x0
   0x000000000040117d <+27>:	jmp    0x4011ac <generate_passcode+74>
   0x000000000040117f <+29>:	mov    eax,DWORD PTR [rbp-0x4]
   0x0000000000401182 <+32>:	and    eax,0x1
   0x0000000000401185 <+35>:	test   eax,eax
   0x0000000000401187 <+37>:	jne    0x40119c <generate_passcode+58>
   0x0000000000401189 <+39>:	mov    eax,DWORD PTR [rbp-0x4]
   0x000000000040118c <+42>:	movsxd rdx,eax
   0x000000000040118f <+45>:	mov    rax,QWORD PTR [rbp-0x10]
   0x0000000000401193 <+49>:	add    rax,rdx
   0x0000000000401196 <+52>:	mov    QWORD PTR [rbp-0x10],rax
   0x000000000040119a <+56>:	jmp    0x4011a8 <generate_passcode+70>
   0x000000000040119c <+58>:	mov    rax,QWORD PTR [rbp-0x10]
   0x00000000004011a0 <+62>:	sub    rax,0x1
   0x00000000004011a4 <+66>:	mov    QWORD PTR [rbp-0x10],rax
   0x00000000004011a8 <+70>:	add    DWORD PTR [rbp-0x4],0x1
   0x00000000004011ac <+74>:	cmp    DWORD PTR [rbp-0x4],0x9
   0x00000000004011b0 <+78>:	jle    0x40117f <generate_passcode+29>
   0x00000000004011b2 <+80>:	mov    rcx,QWORD PTR [rbp-0x10]
   0x00000000004011b6 <+84>:	movabs rdx,0x346dc5d63886594b
   0x00000000004011c0 <+94>:	mov    rax,rcx
   0x00000000004011c3 <+97>:	imul   rdx
   0x00000000004011c6 <+100>:	mov    rax,rdx
   0x00000000004011c9 <+103>:	sar    rax,0xb
   0x00000000004011cd <+107>:	mov    rdx,rcx
   0x00000000004011d0 <+110>:	sar    rdx,0x3f
   0x00000000004011d4 <+114>:	sub    rax,rdx
   0x00000000004011d7 <+117>:	imul   rdx,rax,0x2710
   0x00000000004011de <+124>:	mov    rax,rcx
   0x00000000004011e1 <+127>:	sub    rax,rdx
   0x00000000004011e4 <+130>:	mov    QWORD PTR [rbp-0x10],rax
   0x00000000004011e8 <+134>:	mov    rcx,QWORD PTR [rbp-0x10]
   0x00000000004011ec <+138>:	movabs rdx,0x5555555555555556
   0x00000000004011f6 <+148>:	mov    rax,rcx
   0x00000000004011f9 <+151>:	imul   rdx
   0x00000000004011fc <+154>:	mov    rsi,rcx
   0x00000000004011ff <+157>:	sar    rsi,0x3f
   0x0000000000401203 <+161>:	mov    rax,rdx
   0x0000000000401206 <+164>:	sub    rax,rsi
   0x0000000000401209 <+167>:	mov    rdx,rax
   0x000000000040120c <+170>:	add    rdx,rdx
   0x000000000040120f <+173>:	add    rdx,rax
   0x0000000000401212 <+176>:	mov    rax,rcx
   0x0000000000401215 <+179>:	sub    rax,rdx
   0x0000000000401218 <+182>:	test   rax,rax
   0x000000000040121b <+185>:	jne    0x401229 <generate_passcode+199>
   0x000000000040121d <+187>:	mov    rax,QWORD PTR [rbp-0x10]
   0x0000000000401221 <+191>:	add    rax,0x5
   0x0000000000401225 <+195>:	mov    QWORD PTR [rbp-0x10],rax
   0x0000000000401229 <+199>:	mov    rax,QWORD PTR [rbp-0x10]
   0x000000000040122d <+203>:	leave
   0x000000000040122e <+204>:	ret
End of assembler dump.
```
Figure 4.1: *disassembly of `main` and `generate_passcode` by gdb*

Now that I've proven my point, let's solve this challenge

## Solving the challenge

`volatile_passcode` will be your first proper foray into the world of reverse engineering. This
means that we won't be exploiting any bugs in the program. We will instead be solving the challenge
by figuring out how the passcode is decided by the program, and then typing in a valid passcode as
the developer intended.

### Analysing `main`

The first step to understanding what this program does, is understanding what the `main` function is
doing. Switch back to Ghidra and navigate to the `main` function. The decompilation should look
something like the code in Figure 4.2. To get the flag we need `local_c` to be equal to `local_10`.
These variables have automatically generated names because they are local variables. Let's take a
closer look at each important line.

1. `undefined8` means that Ghidra does not know what type of value the function will return, but it
   does now that the value is 8 bytes. In this case we know that it's returning an `int` because
   that's what C `main` functions should return.
2. `local_10` is the user's passcode input (see 7).
3. `local_c` is the generated passcode (see 6).
4. `signal` sets the handler for a handler. In this case it's setting up the `sighandler` function
   to be called when a `SIGALRM` (`0xe`) is received. See 5 for more.
5. `alarm` tells the operating system to send the `SIGALRM` signal to the program after a certain
   amount of seconds. In this case, after one second. This is how the program annoyingly teases you
   for not typing in the passcode fast enough.
6. A passcode is generated and assigned to `local_c`.
7. `__isoc99_scanf` just means `scanf`. `scanf` is a function used to get input from the user. The
   first argument is a format specifier (e.g. `"%d"` reads the user's input and attempts to convert
   it to an integer). The rest of the arguments are pointers to where to put the input once it has
   been read. For some reason Ghidra does not detect the argument types correctly so to get nice
   output we can right click on `__isoc99_scanf`, select `Edit Function Signature`, enter `undefined
   __isoc99_scanf (char *, int *)` and click `OK`. This will update the line to look like
   `__isoc99_scanf("%d",&local_10)` which makes a bit more sense. We can now see that this line is
   reading whatever integer the user inputs and storing it in `local_10`.
8. If the user's input matches the generated passcode, the program will print out the flag.

```c
undefined8 main(void) // 1

{
  int local_10; // 2
  int local_c; // 3
  
  signal(0xe,sighandler); // 4
  alarm(0x1); // 5
  local_c = generate_passcode(); // 4
  printf("Enter your passcode: ");
  __isoc99_scanf(&DAT_0040201a,&local_10); // 5
  if (local_c == local_10) { // 6
    system("/bin/cat flag.txt");
  }
  else {
    puts("Nope");
  }
  return 0x0;
}
```
Figure 4.2: *decompilation of `main` as produced by Ghidra (with comments added)*

Now that we have a better idea of what the function is doing, we can give those local variables some
nicer names. Right click on `local_10`, select `Rename Variable` and enter `input`. Do the same for
`local_c` and rename it to `passcode`.

### Analysing `generate_passcode`

Figure 4.3 contains the decompilation of `generate_passcode`. I have pre-emptively renamed the two
local variables based on educated guesses about their meaning based on reading the code. Read the
following explanations of each important feature if you are struggling to understand what this
slightly strange code is doing.

1. I renamed this variable to `passcode` because it is the value returned by the function.
2. I renamed this variable to `i` because it is used as the index in the for loop and `i` is the
   name most commonly used for this purpose. Correct names are not important, just choose names that
   make sense to you.
3. The current time in seconds since the Epoch (1970-01-01 00:00:00 +0000 (UTC)) is assigned to
   `passcode`. See `man time` for an explanation of the `time` function.
4. Iterate `i` from 0 to 9. Equivalent to `for i in range(10)` in Python.
5. If `i` is an even number, add `i` to the passcode.
6. If `i` is an odd number, subtract 1 from the passcode.
7. Remove all but the rightmost 4 digits from the passcode (by taking the remainder when dividing by
   10000).
8. If the passcode is a multiple of 3, add 5 to it.

```c
long generate_passcode(void)

{
  long passcode; // 1
  uint i; // 2
  
  time(&passcode); // 3
  for (i = 0; i < 10; i = i + 1) { // 4
    if ((i & 0x1) == 0x0) { // 5
      passcode = passcode + (int)i;
    }
    else { // 6
      passcode = passcode - 1;
    }
  }
  passcode = passcode % 10000; // 7
  if (passcode % 3 == 0) { // 8
    passcode = passcode + 5;
  }
  return passcode;
}
```
Figure 4.3: *decompilation of `generate_passcode` as produced by Ghidra (with comments added)*

You may notice that the algorithm for generating the passcode could be simplified a lot and still
output the same passcode at each point in time. It was implemented this way to force you to use
Ghidra, because otherwise a disassembler would probably suffice.

### Writing the exploit

To write an exploit, all you need to do is replicate this passcode generation algorithm in Python
and then enter a generated passcode into the program using pwntools. You may find that your exploit
occasionally doesn't work, because if the passcode changes between your program generating it and
the challenge binary generating it, you won't get the flag. Just run your exploit a few times and
you should get the flag eventually unless your generation algorithm is incorrect.

You can find a working exploit in `01-volative_passcode/Solution/exploit.py`.
