# The basics | Binary exploitation part 1

In the world of programming languages, there are interpreted languages (such as Python) and
compiled languages (such as C). Interpreted languages require an interpreter which reads the code
line by line and executes the code like a recipe: there is only one step to running an
interpreted program. In contrast, compiled languages require developers to compile their programs
into executable binaries before they can be run, but once compiled, the programs do not require an
interpreter to run and therefore run much faster.

Binary exploitation - as the name suggests - deals mostly with compiled languages, and in particular
C because of its ubiquity. In this area of cybersecurity, the focus is on the exploitation of
programming issues in compiled programs.

## What is a CPU?

CPU stands for Core Processing Unit, and it is the part of the computer that most programs run on.
To run on the CPU, a program must be compiled to machine code, which is a sequence of low level
instructions such as add, subtract, load, store and jump. Each operation is represented by a number
or sequence of numbers, and a program is simply stored as a series of bytes (numbers from 0 to 255
inclusive). These bytes represent the program's instructions along with any data it needs to run.

There are many types (a.k.a architectures) of CPUs available, but the most common is `x86_64` which is
what we will be focussing on. The older version of `x86_64`, `x86`, is stilled used relatively
often, the main difference between the two CPUs being the size of registers (more on this later).
For now we will focus only the 64-bit version (`x86` is 32-bit).

## What is assembly?

A sequence of numbers is clearly not human readable, so to read and write machine code we can use
a text-based representation called assembly. Most binary exploitation challenges only involve x86
assembly, the type of assembly used by most consumer CPUs. There are other types of assembly such as
arm and RISC-V, but we will ignore those for now.

Below is a program written in assembly (Figure 1.1) and a breakdown of its compiled form (Figure 1.2).
These are purely for illustrative purposes and you don't need to understand them at this point.
Only a simple understanding of machine code is required for most binary exploitation.

```asm
global _start

section .text

_start:             ; // The equivalent C code
  mov rax, 1        ; write(
  mov rdi, 1        ;   STDOUT_FILENO,
  mov rsi, msg      ;   msg,
  mov rdx, msglen   ;   msglen
  syscall           ; );

  mov rax, 60       ; exit(
  mov rdi, 0        ;   EXIT_SUCCESS
  syscall           ; );

section .rodata
  msg: db "Hello, world!", 10
  msglen: equ $ - msg
```
Figure 1.1: *a 'Hello, world!' example program written in assembly*

| Machine code                    | Human readable representation |
| ------------------------------- | ----------------------------- |
| `b8 01 00 00 00`                | `mov eax,0x1`                 |
| `bf 01 00 00 00`                | `mov edi,0x1`                 |
| `48 be 00 20 40 00 00 00 00 00` | `movabs rsi,0x402000`         |
| `ba 0e 00 00 00`                | `mov edx,0xe`                 |
| `0f 05`                         | `syscall`                     |
| `b8 3c 00 00 00`                | `mov eax,0x3c`                |
| `bf 00 00 00 00`                | `mov edi,0x0`                 |
| `0f 05`                         | `syscall`                     |

Figure 1.2: *a translation of the raw compiled machine code of the 'Hello, world!' program*

## ELF executables

Machine code isn't much use to us on its own. To turn it into a program we need to put it inside an
executable file. Different operating systems have different executable file formats. On Linux the
format is called ELF.

The layout of an ELF executable is relatively straightforward, and is depicted in Figure 1.3.
Importantly, the machine code instructions are in the `.text` section, constants such as hardcoded
variables are stored in the `.rodata` section. Global variables with initial values are stored in
the `data` section.

```
|----------------------|
| ELF header           | <- basic information about the executable
|----------------------|
| Program header table | <- information required to prepare to prepare the program for execution
|----------------------|
| .text section        | <- machine code
|----------------------|
| .rodata section      | <- read-only data (i.e. constants that do not change during a program's execution)
|----------------------|
| .data section        | <- read-write data (i.e. data that can change during a program's execution)
|----------------------|
| ...                  |
| Other sections       |
| ...                  |
|----------------------|
| Section header table | <- contains the name, address and nature of all sections in the executable (e.g. .text, .rodata, etc.)
|----------------------|
```
Figure 1.3: *annotated layout of an ELF executable*

When a program is run, the operating system will copy most of its contents in memory (excluding
headers). This ensures that the program has quick and simple access to the data and instructions
stored in its sections.

## Your first exploit

Congratulations! You have gained a basic understanding of how compiled programs work, and you're
ready for your first epic exploit :sunglasses:.

The first challenge you will complete is called `safe` and it's located in the `01-safe` directory. The
description for this challenge is as follows:

> You'll never get into my safe because I've set such a strong password!

Lets run the program and see what we're working with.

```console
$ ./safe
Enter the password:
asdf
Better luck next time
```

I tried `asdf` and as you can see, it didn't let us in. If the password is hardcoded into the program
(which it must be because there is no database or similar), it must be stored somewhere in the
executable file (Figure 1.3). Many tools exist for extracting hardcoded values from executables, but
the simplest is called `strings`.

Run `strings ./safe` and see if you can find anything interseting. If you get stuck, you can find
the solution in `safe/Solution/Solution.md`.
